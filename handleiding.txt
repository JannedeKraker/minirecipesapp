1. Java Backend met Spring Boot:

   Open IntelliJ IDEA en maak een nieuw Spring Boot-project met behulp van Spring Initializer.
   Selecteer de benodigde afhankelijkheden, zoals Spring Web, Spring Data JPA en PostgreSQL    Driver.
    Configureer de database-instellingen in het application.properties-bestand.
    Maak Java-klassen voor je entiteiten en repositories met behulp van JPA Spring Data.

2. Frontend met React, JavaScript, en Tailwind:

    Open Visual Studio Code en maak een nieuw projectmap voor je frontend.
    Gebruik de opdracht npm create vite@latest om een nieuw Vite-project te maken.
    Ga naar de projectmap en voer npm install uit om alle afhankelijkheden te installeren.
    Gebruik npm run dev om de ontwikkelingsserver te starten.

3. React Componenten, Props en Router:

    Maak React-componenten in de src-map van je Vite-project.
    Gebruik JSX om de UI van je componenten te definiëren.
    Definieer props om gegevens naar componenten door te geven.
    Gebruik een router zoals react-router om navigatie in je applicatie mogelijk te maken.

4. Communicatie met de Backend:

    Gebruik de fetch()-functie om HTTP-verzoeken vanuit je React-componenten naar de Java-backend te sturen.
    Definieer eindpunten op de Java-backend met behulp van Spring Web Controllers om de verzoeken te verwerken.
    Implementeer de logica om gegevens tussen de frontend en backend uit te wisselen, bijvoorbeeld met JSON.

5. Databasebeheer:

    Gebruik pgAdmin om je PostgreSQL-database te beheren. Maak tabellen voor je applicatie-entiteiten.
    Configureer de databaseverbinding in de backend met de juiste URL, gebruikersnaam en wachtwoord.

6. Version Control met GitHub:

    Maak een GitHub-repository voor je project.
    Initialiseer Git in je projectmappen en voeg alle bestanden toe aan de repository.
    Maak commits en push regelmatig naar GitHub om je werk op te slaan en samen te werken.

Dit is een algemene roadmap voor het opzetten van je webapplicatie met de genoemde technologieën. Onthoud dat elk van deze stappen gedetailleerde configuraties en implementaties vereist. Raadpleeg de officiële documentatie van elke technologie voor diepgaandere informatie en voorbeelden.







1. Java Backend met Spring Boot:
1) Maak een Spring Boot project aan met de normale dependencies

ga naar: https://start.spring.io/ (Dat is de website met spring initializer)

--------------------------------------------------------------------------------------------------------------------------
project: Maven
language: JAVA
SpringBoot: 3.1.3

Project metadata
Group: com.jannedekraker
Artifact: minirecipesapp 	(volgens mij mogen hier geen hoofdletters in en in de naam 				 wel, waarom weer ik nog niet)
Name: miniRecipesApp
Description: excersize mini app
packaging: JAR			(geen idee wat dat is en waarom)
JAVA: 17

Dependencies:
- eventueel Lombok 		(doe ik nu niet, die maakt zelf getters en setters. Java 					 annotation library which helps to reduce boilerplate code.)
- Spring Web 			(Build web, including RESTful, applications using Spring 					MVC. Uses Apache Tomcat as the default embedded 					container. wat dit betekend weet ik nog niet.)
- Spring Data jpa		(Persist data in SQL stores with Java Persistence API using 				Spring Data and Hibernate. wat dit betekend weet ik nog 				niet.)
- PostgreSQL Driver		( A JDBC and R2DBC driver that allows Java programs to 					 connect to a PostgreSQL database using standard, database 				independent Java code. wat dit betekend weet ik nog niet.)
klik --> Generate
--------------------------------------------------------------------------------------------------------------------------

2) pak het uit, laad het in IntelliJ, en maak er een GitHub repository van.

- bestand openen
- unzip/ extract to
C:\Users\janne.dekraker\Documents\it project janne\Itvitae\opdrachtenfase3
- IntelliJ openen
- open map: C:\Users\janne.dekraker\Documents\it project janne\Itvitae\opdrachtenfase3\minirecipesapp
- ga naar VSC - share project on github
- hij staat standaard op private, dat wil ik nu niet omdat wubbo dan kan zien wat ik heb gedaan. dus ik haal het vinkje weg bij private.
- Repository naam staat er automatisch,
- description kopieer ik van initializer.
- bij de add files for initial commit unvink de application.properties.
- klik --> commit
--------------------------------------------------------------------------------------------------------------------------

3) Maak een database (bv "recipes") met pgAdmin

- open pgAdmin
- enter wachtwoord (db)
- klik op servers
- klik op postgresSQL
- rechtermuisknop databases --> create Database
- Database recipes
- owner postgres
- save
--------------------------------------------------------------------------------------------------------------------------

4) Zorg dat de application.properties de juiste waarden krijgt.

- ga naar InteliJ
- ga naar minirecepesapp->src->main->resources->application.properties
- zet dit er in (gekregen van Alexander, geen idee waar hij dit vandaan heeft, ik vermoed dat dit de connectie met postgres voor elkaar krijgt):

spring.datasource.url=jdbc:postgresql://localhost:5432/{*** vul hier de naam van je database in***}
spring.datasource.username=postgres
spring.datasource.password=  {*** Vul hier je wachtwoord in !!***}
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto = update

-vul het wachtwoord in.
-vul de naam van je database in, in dit geval: recipes
- commit --> klik met je rechtermuisknop op application.properties en add to . gitignore (zo komt je wachtwoord van je database niet online te staan)
- vink changes aan
- zet bij commit message: added application.properties to .gitignore
- commit

--------------------------------------------------------------------------------------------------------------------------

5) Maak een Recipe class - dit is een entity class. Geef het een id en title

- ga in IntelliJ naar minirecipesapp\src\main\java\com\jannedekraker\minirecipesapp\MiniRecipesAppApplication.java
- rechtermuisknop new file java class
- Recipe
- add to git
- typ dit (de constructors en getters en setters kan je laten generaten:

package com.jannedekraker.minirecipesapp;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;

@Entity

public class Recipe {
    @Id
    @GeneratedValue
    private long id;

    private String title;

          public Recipe() {
          }

          public Recipe(String title) {
    this.title = title;
         }


    public long getId() {
        return id;
    }


    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}

- commit

(In dit voorbeeld is Recipe een JPA-entityklasse, gemarkeerd met de @Entity-annotatie. Dit vertelt Spring dat deze klasse overeenkomt met een database-entiteit. De @Id-annotatie geeft aan dat het veld id de primaire sleutel van de entiteit is, en de @GeneratedValue-annotatie geeft aan dat de database automatisch unieke id's zal genereren.

Je kunt deze klasse uitbreiden met andere eigenschappen zoals ingrediënten, instructies, enzovoort, afhankelijk van wat je in je receptenapp wilt opslaan.)
--------------------------------------------------------------------------------------------------------------------------


6) Maak een RecipeRepository
- ga in IntelliJ naar minirecipesapp\src\main\java\com\jannedekraker\minirecipesapp\MiniRecipesAppApplication.java
- rechtermuisknop new file java interface
- typ RecipeRepository
- typ dit:

package com.jannedekraker.minirecipesapp;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface RecipeRepository extends JpaRepository<Recipe, Long> {
    // Add any custom query methods if needed
}

(In dit voorbeeld breidt de RecipeRepository het JpaRepository uit, dat wordt geleverd door Spring Data JPA. Hiermee krijg je out-of-the-box CRUD (Create, Read, Update, Delete) operaties en query-ondersteuning zonder dat je veel boilerplate-code hoeft te schrijven.

Je kunt ook aangepaste query-methoden toevoegen aan de repository-interface als je specifieke zoekoperaties nodig hebt die niet worden gedekt door de standaard CRUD-operaties.)
--------------------------------------------------------------------------------------------------------------------------
7) Maak een RecipeController
- ga in IntelliJ naar minirecipesapp\src\main\java\com\jannedekraker\minirecipesapp\MiniRecipesAppApplication.java
- rechtermuisknop new file java class
- RecipeController
- add to git
- typ dit
package com.jannedekraker.minirecipesapp;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("api/v1/recipes")
public class RecipeController {

    private final RecipeRepository recipeRepository;

    @Autowired
    public RecipeController(RecipeRepository recipeRepository) {
        this.recipeRepository = recipeRepository;
    }

    @GetMapping
    public ResponseEntity<List<Recipe>> getAllRecipes() {
        List<Recipe> recipes = recipeRepository.findAll();
        return ResponseEntity.ok(recipes);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Recipe> getRecipeById(@PathVariable Long id) {
        Recipe recipe = recipeRepository.findById(id).orElse(null);
        if (recipe != null) {
            return ResponseEntity.ok(recipe);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    @PostMapping
    public ResponseEntity<Recipe> createRecipe(@RequestBody Recipe recipe) {
        Recipe savedRecipe = recipeRepository.save(recipe);
        return ResponseEntity.ok(savedRecipe);
    }


    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteRecipe(@PathVariable Long id) {
        if (recipeRepository.existsById(id)) {
            recipeRepository.deleteById(id);
            return ResponseEntity.noContent().build();
        } else {
            return ResponseEntity.notFound().build();
        }
    }
}

(In dit voorbeeld definieert de RecipeController verschillende HTTP-eindpunten om CRUD-operaties op recepten uit te voeren. Hier zijn enkele belangrijke punten:

    @RestController geeft aan dat dit een controller is die JSON-responsen retourneert.
    @RequestMapping("/recipes") specificeert het basismappingpad voor alle eindpunten in deze controller.
    De @Autowired-annotatie injecteert de RecipeRepository in de controller.
    @GetMapping definieert een eindpunt om alle recepten op te halen.
    @PostMapping definieert een eindpunt om een nieuw recept te maken.
    @PutMapping definieert een eindpunt om een bestaand recept bij te werken.
    @DeleteMapping definieert een eindpunt om een recept te verwijderen.
    @PathVariable wordt gebruikt om variabelen uit het pad van de URL te extraheren.
    @RequestBody wordt gebruikt om het verzoeklichaam naar een object te binden.

Houd er rekening mee dat dit slechts een basisvoorbeeld is en je kunt dit aanpassen en uitbreiden op basis van de vereisten van je applicatie.)
--------------------------------------------------------------------------------------------------------------------------

8) Geef de RecipeController een Get-endpoint, dat nu gewoon "hello recipes!"
teruggeeft

- zet dit bij de getmappings

  @GetMapping("/hello")
    public ResponseEntity<String> helloRecipes() {
        return ResponseEntity.ok("hello recipes!");
    }
--------------------------------------------------------------------------------------------------------------------------

9) Run het project en test uit in de browser of je het endpoint terugkrijgt

- ga naar MiniRecipesAppApplication in IntelliJ
- en druk op runnen
- open webbrowser http://localhost:8080/api/v1/recipes/hello

(in je recipeController kan je zien wat er na http://localhost:8080/ moet komen te staan. achter @RequestMapping staat het eerste gedeelte:("api/v1/recipes").
en achter @GetMapping staat het tweede gedeelte("/hello"))



--------------------------------------------------------------------------------------------------------------------------

10) Maak een seeder voor je database, die er recepten in aanbrengt als hij leeg is





2. Frontend met React, JavaScript, en Tailwind:
tailwind installeren:
https://tailwindcss.com/docs/guides/vite
